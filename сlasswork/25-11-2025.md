# Работа на занятии 25‑11‑2025  
## Работа с базами данных SQLite и переменными окружения  

На этом занятии мы научимся хранить данные не в оперативной памяти, а в настоящей базе данных. Это значит, что после перезапуска программы все клиенты останутся на месте!

---

### 1. Создаём файл `.env` для хранения секретов  

**Что это такое:**  
Файл `.env` — это специальный файл, где хранятся секретные данные (токены, пароли). Его не добавляют в Git, чтобы никто не украл ваши секреты.

**Что делаем:**  
Создаём файл `.env` в корне проекта и записываем туда токен от Telegram-бота.

**Код:**  
```
TELEGRAM_TOKEN=вставляем свой токен из BotFather
```

**Важно:**  
- Файл называется именно `.env` (с точкой в начале).  
- Между `TELEGRAM_TOKEN`, знаком `=` и значением **нет пробелов**.  
- Этот файл нужно добавить в `.gitignore`, чтобы случайно не выложить токен в интернет.

---

### 2. Обновляем `config.py` для чтения секретов  

**Зачем это нужно:**  
Вместо того чтобы писать токен прямо в коде (это небезопасно!), мы читаем его из файла `.env`.

**Как это работает:**  
1. Функция `load_dotenv('.env')` загружает все переменные из файла `.env`.  
2. Функция `os.environ.get("TELEGRAM_TOKEN")` достаёт значение переменной по её имени.

**Код:**  
```python
from dotenv import load_dotenv
import os

load_dotenv('.env')

TELEGRAM_TOKEN = os.environ.get("TELEGRAM_TOKEN")
```

**Разбор по строкам:**  
- `from dotenv import load_dotenv` — подключаем функцию для чтения `.env` файлов.  
- `import os` — подключаем модуль для работы с системными переменными.  
- `load_dotenv('.env')` — читаем файл `.env` и загружаем его содержимое.  
- `TELEGRAM_TOKEN = os.environ.get("TELEGRAM_TOKEN")` — получаем значение токена и сохраняем в переменную.

**Результат:**  
Теперь токен хранится безопасно, и мы можем использовать переменную `TELEGRAM_TOKEN` в других файлах.

---

### 3. Создаём файл `database.py` и подключаем SQLite  

**Что такое SQLite:**  
SQLite — это простая база данных, которая хранится в одном файле. Не нужно устанавливать сервер — всё работает «из коробки» в Python!

**Что делаем:**  
Создаём новый файл `database.py` и импортируем библиотеку для работы с базой данных.

**Код:**  
```python
import sqlite3
```

**Что это значит:**  
- `import sqlite3` — подключаем встроенную библиотеку Python для работы с базами данных SQLite.  
- Эта библиотека уже есть в Python, ничего устанавливать не нужно!

---

### 4. Создаём подключение и таблицу в базе данных  

**Что делаем:**  
1. Создаём папку `.tmp` (если её нет — создайте вручную).  
2. Подключаемся к базе данных (если файла нет — он создастся автоматически).  
3. Создаём таблицу для хранения клиентов.

**Код:**  
```python
conn = sqlite3.connect('.tmp/clients.db')
cursor = conn.cursor()

# создать таблицу clients
cursor.execute('''
    CREATE TABLE IF NOT EXISTS clients (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        name TEXT NOT NULL,
        phone TEXT NOT NULL,
        telegram TEXT NOT NULL
    )
''')
```

**Разбор по строкам:**  

- `conn = sqlite3.connect('.tmp/clients.db')` — подключаемся к базе данных. Если файла `clients.db` нет, он создастся автоматически.  
- `cursor = conn.cursor()` — создаём «курсор» — это как указка, которая выполняет команды в базе данных.  
- `cursor.execute(...)` — выполняем SQL-команду.

**Разбор SQL-команды:**  
```sql
CREATE TABLE IF NOT EXISTS clients (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    name TEXT NOT NULL,
    phone TEXT NOT NULL,
    telegram TEXT NOT NULL
)
```

- `CREATE TABLE` — создать таблицу.  
- `IF NOT EXISTS` — только если такой таблицы ещё нет (чтобы не было ошибки при повторном запуске).  
- `clients` — название таблицы.  
- `id INTEGER PRIMARY KEY AUTOINCREMENT` — уникальный номер клиента, который увеличивается автоматически.  
- `name TEXT NOT NULL` — имя клиента (текст, обязательное поле).  
- `phone TEXT NOT NULL` — телефон клиента (текст, обязательное поле).  
- `telegram TEXT NOT NULL` — Telegram клиента (текст, обязательное поле).

**Результат:**  
В папке `.tmp` появится файл `clients.db` — это и есть наша база данных!

---

### 5. Добавляем функцию для сохранения клиента в базу  

**Что делаем:**  
Создаём функцию, которая добавляет нового клиента в базу данных.

**Код:**  
```python
def client_add_db(name, phone, telegram):
    # добавить пользователя
    conn = sqlite3.connect('.tmp/clients.db')
    cursor = conn.cursor()

    print(name, phone, telegram)
    cursor.execute('INSERT INTO clients (name, phone, telegram) VALUES (?, ?, ?)', (name, phone, telegram))
    conn.commit()

    # закрываем базу данных
    conn.close()
```

**Разбор по строкам:**  

- `def client_add_db(name, phone, telegram):` — создаём функцию с тремя параметрами: имя, телефон и телеграм.  
- `conn = sqlite3.connect('.tmp/clients.db')` — подключаемся к базе данных.  
- `cursor = conn.cursor()` — создаём курсор для выполнения команд.  
- `print(name, phone, telegram)` — выводим данные для проверки (можно убрать потом).  
- `cursor.execute('INSERT INTO clients ...', (...))` — выполняем SQL-команду для добавления записи.  
- `conn.commit()` — **ВАЖНО!** Сохраняем изменения в базе данных.  
- `conn.close()` — закрываем соединение с базой данных.

**Разбор SQL-команды:**  
```sql
INSERT INTO clients (name, phone, telegram) VALUES (?, ?, ?)
```

- `INSERT INTO clients` — вставить запись в таблицу `clients`.  
- `(name, phone, telegram)` — в какие колонки вставляем.  
- `VALUES (?, ?, ?)` — знаки `?` — это «заглушки», куда подставятся реальные значения.  
- `(name, phone, telegram)` — второй аргумент функции `execute()` — это значения для подстановки.

**Почему используем `?` вместо значений напрямую:**  
Это защита от SQL-инъекций — специальных атак, когда злоумышленник может сломать вашу базу данных через ввод данных.

**Результат:**  
Теперь мы можем вызвать `client_add_db("Олег", "+7 999 123 45 67", "@oleg")` и клиент сохранится в базе!

---

### 6. Функция для получения всех клиентов из базы  

**Что делаем:**  
Создаём функцию, которая читает всех клиентов из базы данных.

**Код:**  
```python
def client_read_db():
    # получить всех пользователей
    cursor.execute('SELECT * FROM clients')
    return cursor.fetchall()
```

**Разбор по строкам:**  

- `def client_read_db():` — создаём функцию без параметров.  
- `cursor.execute('SELECT * FROM clients')` — выполняем SQL-запрос.  
- `return cursor.fetchall()` — возвращаем все найденные записи.

**Разбор SQL-команды:**  
```sql
SELECT * FROM clients
```

- `SELECT` — выбрать (получить) данные.  
- `*` — все колонки (id, name, phone, telegram).  
- `FROM clients` — из таблицы `clients`.

**Что возвращает `fetchall()`:**  
Список кортежей (похоже на список списков). Например:
```python
[
    (1, 'Олег', '+7 999 123 45 67', '@oleg'),
    (2, 'Дима', '+7 999 765 43 21', '@dima')
]
```

---

### 7. Закрываем базу данных  

**Зачем это нужно:**  
После работы с базой данных нужно закрыть соединение, чтобы освободить ресурсы компьютера.

**Код:**  
```python
conn.close()
```

**Важно:**  
- Всегда закрывайте соединение после работы с базой!  
- Если не закрыть — могут быть проблемы при повторном подключении.

---

## Итоговый код файла `database.py`

```python
import sqlite3

conn = sqlite3.connect('.tmp/clients.db')
cursor = conn.cursor()

# создать таблицу clients
cursor.execute('''
    CREATE TABLE IF NOT EXISTS clients (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        name TEXT NOT NULL,
        phone TEXT NOT NULL,
        telegram TEXT NOT NULL
    )
''')

def client_add_db(name, phone, telegram):
    # добавить пользователя
    conn = sqlite3.connect('.tmp/clients.db')
    cursor = conn.cursor()

    print(name, phone, telegram)
    cursor.execute('INSERT INTO clients (name, phone, telegram) VALUES (?, ?, ?)', (name, phone, telegram))
    conn.commit()

    # закрываем базу данных
    conn.close()

def client_read_db():
    # получить всех пользователей
    cursor.execute('SELECT * FROM clients')
    return cursor.fetchall()

conn.close()
```

---

## Словарь терминов  

| Термин | Объяснение |
|--------|------------|
| **SQLite** | Простая база данных, которая хранится в одном файле |
| **База данных** | Место для хранения данных, которые сохраняются после выключения программы |
| **Таблица** | Структура в базе данных, похожая на таблицу в Excel |
| **SQL** | Язык запросов для работы с базами данных |
| **cursor** | «Указка» для выполнения команд в базе данных |
| **commit()** | Сохранение изменений в базе данных |
| `.env` | Файл для хранения секретных данных (токенов, паролей) |
| **Переменная окружения** | Переменная, которая хранится в системе, а не в коде |

---

## Что мы узнали на этом занятии  

✅ Как безопасно хранить секреты в файле `.env`  
✅ Как читать переменные окружения в Python  
✅ Что такое SQLite и зачем нужны базы данных  
✅ Как создать таблицу в базе данных  
✅ Как добавлять записи в базу данных  
✅ Как читать записи из базы данных  
✅ Почему важно закрывать соединение с базой  
